---
title: "Entitas源码阅读"
date: 2023-01-28T11:53:00+08:00
draft: false
isCJKLanguage: true
---

## 前言
Entitas源码地址: https://github.com/sschmid/Entitas

## 总览
 - Context相当于一个二维表，多个Context就相当于多个二维表（GameContext、InputContext）
 - Entity相当于二维表里的一行数据
 - Component相当于二维表里的一列数据
   > 所以有说法，当Component过多且每个Entity的Component过于稀疏的时候，Entitas目前是比较浪费内存的，在Entitas里可以考虑拆分多个Context来缓解这一问题
 - Group就是根据Component（用Match来指定）来找到对应的Entity
   > 所以当有大量的Entity及其频繁的增删Component的时候，Group会有性能问题，官方对这个也有[FAQ](https://github.com/sschmid/Entitas/wiki/FAQ#q-how-groupsmatcher-collector-affect-performance)
 
## 关于Match
 - 核心逻辑很简单，每个Component都对应一个数字下标（生成代码自动写死），直接用下面这个函数判断某个下标的Component是否存在就可以
   ```csharp
   public bool Matches(TEntity entity) {
       return (_allOfIndices == null || entity.HasComponents(_allOfIndices))
           && (_anyOfIndices == null || entity.HasAnyComponent(_anyOfIndices))
           && (_noneOfIndices == null || !entity.HasAnyComponent(_noneOfIndices));
   }
   ```
 - 不能支持非常复杂的嵌套，比如以下代码会直接Exception
   > 我猜测不是因为无法写得很复杂，而是现有的写法已经很耗费性能了（参考[FAQ](https://github.com/sschmid/Entitas/wiki/FAQ#q-how-groupsmatcher-collector-affect-performance)），要是写再复杂点，估计性能爆炸
   ```csharp
   // MatcherException: matcher.indices.Length must be 1 but was 3
   var exceptionGroup = m_Game.GetGroup(
       GameMatcher.AnyOf(
           GameMatcher.AnyOf(GameMatcher.LanguageScore, GameMatcher.MathScore).NoneOf(GameMatcher.Male),
           GameMatcher.AllOf(GameMatcher.Name).NoneOf(GameMatcher.Female)
       )
   );
   ```
 
## 关于Group

## 关于AERC
 - AERC 是 Automatic Entity Reference Counting 的缩写
 - 它是一个给Entity计数用的实现，每个Entity都会有一份这个类，并且这个类本身是没有对象池实现的
 - 分为安全的计数实现（HashSet保存被引用的对象）和不安全的计数实现（只保存引用的次数）

## Entity的声明周期

### 创建Entity`Context.CreateEntity()`
 - 如果对象池里有Entity则复用
 - 如果对象池为空，则用构造Context类传进来的工厂函数创建一个Entity（默认是直接new），并初始化Entity
   - 为Entity创建一个AERC（默认实现没有用对象池）
   - Context自增的creationIndex（某种程度上可以用于做唯一ID？）
   - 传入Component的数量并且初始化成一个 `IComponent[]`（也即初始化每一列为空，且Component最好是class而不是struct，避免这里无意义的装箱）
   - 传入Component对象池
   - 传入ContextInfo，用于更好的展示错误信息，默认全局共享一份从Context类里传入的
 - 加入到Context类中的 `_entities` HashSet中
 - Entity也继承了IAERC接口，里面的实现就是直接调用为它创建的AERC类
 - Entity的Component增删改事件都会调用Context里的事件，分别对应如下（之所以中间用一个Event转换一下，主要是性能，一个委托就是一个class，这里只创建一个就够了）
   - ComponentAdd、ComponentRemoved --> _cachedEntityChanged --> `updateGroupsComponentAddedOrRemoved()`
   - OnComponentReplaced --> _cachedComponentReplaced --> `updateGroupsComponentReplaced()`
   - OnEntityReleased --> _cachedEntityReleased --> `onEntityReleased()`
   - OnDestroyEntity --> _cachedDestroyEntity --> `onDestroyEntity()`
   
### 给Entity添加Component`GameEntity.AddName()`（注：`AddName()`是我自己声明的NameComponent生成的代码)
 - 创建Component（对象池有则从对象池获取，没有则直接new）
 - 对Component赋值
 - `AddComponent(index, component)`
   - 清除一些缓存（_componentsCache, _componentIndicesCache, _toStringCache）
   - OnComponentAdded(this, index, component) --> `Context.updateGroupsComponentAddedOrRemoved()`

### 给Entity移除Component`GameEntity.RemoveName()`
 - 清除一些缓存差不多
 - 都是调用`replaceComponent(index, IComponent replacement)`
 - 如果是Remove，则调用 OnComponentRemoved(this, index, component) --> `Context.updateGroupsComponentAddedOrRemoved()`，并且将Component还回对象池
 - 如果是Replace，分为两种情况，一种是原样替换（同一个对象但值不一样），一种是新的替换旧的（不同的对象）
   - 新的替换旧的会把旧的入池
   - 两者都会调用 OnComponentReplaced() --> `Context.updateGroupsComponentReplaced()`
   
### 销毁Entity`Entity.Destroy()`
   
## 关于Context的事件
### `Context.updateGroupsComponentAddedOrRemoved()`
 - 对应的是Component的添加和删除
 - 这个函数的主要功能是更新Group
 - 创建Group的时候，会声明一个 `List<Group>[]` 数组，下标对应的就是Component的Index，这样一来就可以做到当某个Component变化时，找到对应的Group列表
 - 每个Group执行HandleEntity()，对Entity执行Match，符合的就添加进来，不符合的就移除出去，并且返回一个GroupChange的委托对象
 - 其中 _groupChangedListPool 只是一个委托列表对象池，用于减少GC的，盲猜一手这个Event是给Collector用的，其他地方好像没有监听Group
 
### `Context.updateGroupsComponentReplaced()`
 - 对应Component的替换
 - 主要用于更新Group（`Group.UpdateEntity()`）
 - 只是调用了一下Group中的Entity更新事件，猜测是用于Collector
