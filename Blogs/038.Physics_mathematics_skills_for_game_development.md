---
title: "《游戏开发中的数学与物理》"
date: 2021-04-27T11:49:09+08:00
draft: false
isCJKLanguage: true
---

# 第一章 物体的运动

## 1.3 让物体沿任意方向运动

### 1.3.0 请将角的单位统一为弧度

为什么计算机中的正弦余弦函数不适用看上去比较亲切易懂的角度，而用了看来不够直观的弧度呢？

其实在近代数学中，三角函数几乎都使用弧度，很少会使用角度。之所以使用弧度而不是使用角度作为角的度量单位，主要是关系到微积分的一些问题。如果坚持不适用弧度的话，三角函数中与微积分相关的一些公式几乎都无法使用，还可能会引发一些严重的问题。特别是游戏中会有与物理相关的公式，稍复杂的情况都会出现微积分的计算，因此读者朋友们在程序中涉及角的度量时，请务必使用弧度而不要使用角度。如果在一个程序中同时使用弧度和角度，就会非常容易出现BUG以及各种问题，因此将角的度量单位无条件统一为弧度这一原则，应当被无条件的贯彻下去。

> ❗ 注意：
>
> 代码中需要将弧度的大小限制在 0 ~ 2π 
>
> 尽管数学中可以任意的将弧度无限大的写下去，但计算机中由于弧度是用浮点数表示的，所以过大的弧度，会导致计算时的精度丢失问题。



## 1.4 在物体运动中加入重力

> 关键词：抛物运动、重力加速度、计算误差、积分

### 1.4.1 关于重力加速度的单位

游戏中配置的重力加速度值并不是自然界中平时使用的9.8。众所周知的重力加速度值9.8是真实的地球上的重力加速度，以 `m/s²(米/平方秒)`为单位，并不能在计算机的虚拟空间中适用。计算机所使用的重力加速度单位是特殊的`dot/F²(像素/平方帧)`，请注意区别。

> 书中示例的重力加速度值是 `0.4 dot/F²`
>
> UCC插件中使用的默认重力加速度是`3.92 dot/F²`
>
> > 百度百科：
> >
> > 大多数网页制作常用图片分辨率为72，即每英寸像素72。一英寸等于2.54厘米，那么一厘米大约28像素
>
> 按照一厘米28像素，一秒60帧换算如下：
>
> `9.8 * 28 * 100 / (60 * 60) = 7.62 dot/F²` 
>
> 反过来推算每厘米的像素数：
>
> `3.92 * 60 * 60 / (9.8 * 100) = 14.4 像素/每厘米`
>
> 🤔这个单位换算哪里怪怪的



### 1.4.2 使用积分进行计算重力运行的轨迹

当存在加速度时，一帧的开始时和结束时速度是不一样的，那么要如何计算这一帧的移动距离呢？

可以使用取平均速度来拟合，当然更好的办法是根据加速度、起始速度、时间，求积分，积分结果为移动的距离。

>关于重力加速度造成的竖直方向的移动轨迹计算的比较：
>
>普通的拟合运算： `y = 1/2 * G * t * t + C2`（C2是初始位置）
>
>积分运算： `y = 1/2 * G * t * t + C1 * t + C2`  （ C1是初始速度， C2是初始位置）
>
>显然，随着时间的推移，后面的 `C1 * t` 造成的误差会越来越大

对位置叠加速度，再对速度叠加加速度这一简单算法，再程序中随着时间的推进，误差会越来越大。如果真正的游戏中出现了这种误差，游戏的玩家很可能会认为游戏有问题。

比如球类比赛游戏中，球的旋转以及空气摩擦的影响等因素都必须考虑在内，如果有误差就有可能会影响球的运动轨迹。在动作游戏中，一点微小的动作偏差都会影响游戏性，最终演变成大问题。

> ❗ 注意：
>
> 那么是不是使用上面的积分来精确计算轨道就万无一失了呢？很遗憾这是不可能的。如果地球上只有重力这一种力的话还没什么问题，但是物体运动往往受到多个复杂的力的共同作用，想精确求得物体每一个瞬间的轨道几乎是不可能的，这种情况下只能根据数据计算物体近似的运动轨道。



## 1.5 物体随机飞溅运动

> 关键词：随机数、均匀随机数、正态分布
>
> 比如火山喷发、烟花、摩擦迸出的火花等，不过物体飞溅运动其本质也是抛物线运动

### 1.5.0 产生随机数时注意事项

RAND_MAX 为`rand()`函数返回的最大值，

获取`0 ~ 1`之间的随机数：

- `rand() / ( float )RAND_MAX`

获取`0 ~ n`之间的随机数：

- `( rand() / (float)RAND_MAX ) * n`（不推荐）

- ` rand() * n / (float)RAND_MAX `（推荐）

如果`n`是整型，那么第二种写法先执行整型乘法，速度更快🤔。

### 1.5.1 正态分布，使火山喷发的随机速度看起来更自然

> 自然界中火山喷发的初速度分布并不是**均匀随机数**，而是满足**正态分布**的

**Box-Muller算法**是一种能根据均匀分布的随机数来产生正态分布的随机数的算法：

假设**a**、**b**是两个服从均匀分布并且取值范围为从0到1的随机数，我们就可以通过下面的公式获得两个满足正太分布（均数为0，标准差为1）的随机数Z1和Z2。
$$
Z_1 = \sqrt{-2ln(a)} cos(2 \pi b)
$$

$$
Z_2 = \sqrt{-2ln(a)} sin(2 \pi b)
$$

等式中的`ln(x)`代表自然对数的函数，上式对应的图像是在半径为 
$$
\sqrt{-2ln(a)}
$$

的圆上取随机角度的点，点的x坐标为Z1，y坐标为Z2。为什么这样的Z1和Z2会满足正态分布呢？超出本书范畴，略过。



## 1.6 让物体进行圆周运动

> 关键词：角速度、向心力

### 1.6.1 基于三角函数实现圆周运动

普通的做法，不考虑物体运动中速度和加速度的情况（比如重力），而是直接计算了物体的位置。我们知道根据三角函数的正弦余弦定义有
$$
x = cos\theta \space\space y = sin\theta
$$

在一个以原点为中心的单位圆上，根据角度θ就可以表示一个点的位置（参考图1-6-2）。

如果上式中θ的值随实践递增，就会形成以原点为中心半径为1的圆周运动（参考图1-6-3）。

将这个圆的半径乘以r，并将原点的位置设置为(x0, y0)，那么围绕着(x0, y0)的半径为r的圆周运动就为
$$
x = r \cdot cos\theta + x_0
$$

$$
y = r \cdot sin\theta + y_0
$$
![](https://raw.githubusercontent.com/lightjiao/lightjiao.github.io/develop/static/images/038/1-6-2.png)

在物理学中表示物体的旋转速度时常使用**角速度**。角速度为w：
$$
w = \dfrac{\theta}{t}
$$
周期T为旋转一周的时间
$$
w = \dfrac{2\pi}{T} \space即\space \theta = 2\pi\dfrac{t}{T}
$$

### 1.6.2 基于向心力实现圆周运动（性能更好）

> ❗那么如果速度中包含了加速度的圆周运动如何计算呢？（比如有重力和空气阻力）  
> ❗或者处理不完整的圆周运动（荡秋千）

> 使用微分处理圆周运动中的加速度

微分的运算过程是分别算单位时间内，x方向和y方向的速度、加速度随时间的函数：
$$
速度v = \dfrac{dx}{dt}
$$
$$
加速度a = \dfrac{dv}{dt}
$$

x方向的位置函数用角速度表达如下：
$$
x = r \cdot cos(wt)
$$
x方向的速度计算如下：
$$
v_x = \dfrac{dx}{dt} = \dfrac{d}{dt}\{r \cdot cos(wt)\} = -rw \cdot sin(wt)
$$
x方向的加速度计算如下：
$$
a_x = \dfrac{dv_x}{dt} = \dfrac{d}{dt}\{(-rw \cdot sin(wt))\} = -rw^2 \cdot cos(wt)
$$
将上面x的等式带入可获得：
$$
a_x = -w^2x
$$
同理可得：
$$
a_y = -w^2y
$$
从向量的角度来重新审视一下上面的等式，可以得出这样一个结论，即将物体所在的位置乘以 `-w² `作为加速度，就会形成以原点为中心的圆周运动（参考图1-6-4）。

![](https://raw.githubusercontent.com/lightjiao/lightjiao.github.io/develop/static/images/038/1-6-4.png)

等式中的负号，表示被施加的加速度（或力）是始终指向原点（即旋转的中心方向）的。于是我们就可以得出结论，即**对物体施加一个指向某一点的角速度为w的力，物体就会围绕该点做圆周运动。**这个力也被称为**向心力**。

❗由于基于向心力实现圆周运动并没有使用sin、cos等三角函数进行运算，只是简单的使用了加法乘法等，而最终效果与使用了三角函数的圆周运动是完全一样的。这种方式性能更好。

❗也正是因为x、y方向的速度、加速度分开计算，所以也更容易加入重力加速度的实现。

>❗❗❗
>
>- 物体原本有一个围绕中心点运动的角速度w（对应到速度就是 w · r），此时如果对物体施加一个大小为 -w² 的一直指向中心点的力，那么这个物体就会围绕中心点做圆周运动。
>
>- 这种情况下如何把重力的影响添加进来呢？
>
>  求出重力g对y方向速度分量的加成，这个加成不是简单的 v_y += at；而是要考虑原本圆周运动的方向。
>  改为直接求g对运动方向速度的加成，这样可以直接求 v += at，进而可以分别求出对v_x，v_y的加成，以及对角速度的加成
>
>  ```
>  // 运动方向的向量
>  var velocity = m_vx * Vector3.right + m_vy * Vector3.up;
>  
>  // 重力加速度对运动方向速度的影响
>  var gravityOnVelocity = Vector3.Dot(m_Gravity * Vector3.down, velocity) / velocity.magnitude;
>  velocity = velocity.normalized * (velocity.magnitude + gravityOnVelocity * Time.fixedDeltaTime);
>  
>  // 重力影响过后的速度换算成速度分量和角速度
>  m_vx = Vector3.Dot(velocity, Vector3.right);
>  m_vy = Vector3.Dot(velocity, Vector3.up);
>  m_Angle_Vel = velocity.magnitude / m_R;
>  ```
>
>- 但这种直接求重力对运动方向速度加成的方法，会使得圆周运动不那么圆
>
>  ![](https://raw.githubusercontent.com/lightjiao/lightjiao.github.io/develop/static/images/038/1-6-99.png)
>
>- 改进：



## 1.7 [进阶]微分方程式及其数值解法

> 关键词：微分方程、数值解法、欧拉法

### 求解积分

有一些运动方程可以通过微积分运算求得，比如重力加速度下的物体运动轨迹x满足积分公式：
$$
\int \dfrac{d^2x}{dt^2} dt = \int g dt
$$

可求得：
$$
x = \frac{1}{2}gt^2 + C_0t + C_1
$$

### 利用三角函数求解积分

但现实中几乎没有人会像这样对运动方程进行积分求解。例如，根据**胡克定律**，具有弹性的物体会被施加一个名为 `-kx`的力，k称为**劲度系数**，弹簧越硬劲度系数越大，此时积分公式为：
$$
\dfrac{d^2x}{dt^2} = \dfrac{-kx}{m}
$$

这个公式无法简单的对两边进行积分求解x，因为积分求解的对象是x，而x在等式右边也出现了。换一种思路，可以利用三角函数两次积分会变回原来的样子来求解。（求解过程略）

### 微分方程的数值解法（欧拉法）

上面介绍了运动方程的两种解法：对等式两边积分以及利用三角函数。但很遗憾，并不是所有微分方程都可以通过这两种方法求解。数学家的研究成果是线性微分方程必然有解，非线性微分方程会存在一些无论如何都无法求解的情况。

我们要使用**微分方程的数值解法**，又叫**欧拉法**。所谓**欧拉法**，就是通过逐步计算来求得微分方程的近似解。

举个例子：

位置x与速度v之间的关系
$$
\dfrac{dx}{dt} = v
$$
在欧拉法中表示为
$$
\dfrac{\Delta x}{\Delta t} = v
$$
这里的Δt是时间间隔（**在游戏中就是1帧**）。用n-1表示前一次的位置，n表示当前的位置
$$
x_n = x_{n-1} + v\Delta t
$$
同理，速度与加速度的关系为
$$
v_n = v_{n-1} + a\Delta t
$$
只要Δt足够小就直接转化为了微分，也就不是近似值了。游戏中经常会把欧拉法的等式中的Δt设置为1，即
$$
\begin{cases}
  x_n = n_{n-1} + v\\
  v_n = v_{n-1} + a
\end{cases}
$$
这样计算所使用的时间间隔就变成了1帧，即1/60秒。在物体被施加了加速度的情况下，这样计算所产生的误差是无法被忽视的。即便如此，很多游戏中也并不会去要求更高的计算精度，因为此时物体的动作肉眼观察起来并不会感到奇怪，这就足够了。

如果一些情况需要提高精度的话（比如球类游戏），一般有一下三个方法：

1. 使用精度更高的高阶近似求解微分方程，比如龙格-库塔法等。
2. 使用线性多步法计算，即不光使用前一次的值，还使用前两次或更早的值进行计算，比如Adams-Bashforth法等。
3. 在一帧内多次使用欧拉法计算，缩小Δt。

方法一偏理论，代码维护性差，而且龙格-库塔法本身有很多版本，会有混乱，请慎重

方法二比一略简单一些，也没有那么多不同版本，但毫无疑问还是比欧拉法复杂，斟酌使用

方法三最常用，循环10次欧拉法就很好用了。



# 第二章 卷动

## 2.3 卷动由地图块组合的地图

> 关键词：地图、地图块、整数的减法、位移运算、逻辑运算

### 位移运算

- 用 `>> 6` 来代替除以64（64是2的6次方）

  > 以前CPU指令中还没有除法运算，或者除法运算特别花时间的时期多用这种手法。
  >
  > 但现在除法运算指令已经非常高速。
  >
  > 现代的CPU中大都内置了名为“桶形移位器”的逻辑电路，可以在一个时钟周期内进行任意长度的位移，因此如果是在数量非常巨大的循环中，将除法运算替换为位运算会获得更快的速度。

- 用`& 0x3f`来代替乘以64（TODO）

  > 现在CPU中乘法运算的速度与逻辑运算的速度差别比起以前已经非常小了，因此使用逻辑运算的必要性也变小了。
  >
  > 不过即便乘法运算能在CPU的一个时钟周期内完成，但乘法运算和逻辑运算分别在CPU的不同单元中处理时，由于按顺序执行的乘法运算和逻辑运算可以并行处理，因此还不能说逻辑运算已经完全可以被替代。



## 2.4 波纹式的摇摆卷动

> 关键词：波纹扭曲、正弦波、波长、振幅、周期

将一张图片的各个部分通过卷动变形，并呈现波纹式的摇摆。其实就是将图片按像素划分成一行一行，分别修改每一行的渲染的起始坐标。

### 正弦波

![](https://raw.githubusercontent.com/lightjiao/lightjiao.github.io/develop/static/images/038/2-4-4.png)
$$
y = A \cdot sin(\dfrac{2\pi}{\lambda} x)
$$
公式中的正弦波包含振幅A与波长λ两个特征。

振幅A表示振动的幅度大小，振幅越大说明波震动的幅度越大。

波长λ表示波在1个周期内波动的距离，其值越大，波形越宽。

包含时间的正弦波公式：
$$
y = A \cdot sin\{2\pi(\dfrac{t}{T} - \dfrac{x}{\lambda})\}
$$
变量t表示经过的时间。在这个正弦波公式中出现了振幅A、波长λ，还有周期T。

周期T表示多长时间是一个周期，其值越大，一次波动所经过的时间越长。

上式中时间每推进T，正弦函数中就增加2π。

自然界中存在很多种波，与正弦波相似的波也有不少，因此通过正弦波就能大致表现出很多真实世界中的波（但是像水面那样的波严格来说并不是正弦波）。



## 2.5 制作有纵深感的卷动

> 关键词：透视、比例计算、梯形

用2D图像表现出有纵深的3D效果。



## 2.6 [进阶]透视理论

并没有很复杂，就是利用3D坐标到视点的位置连线，计算出连线与屏幕位置的焦点，然后在该点绘制出图形

透视用的是一个三角锥体，也有直接用矩形立方体的就没有透视

不过这样也是有缺陷的，主要缺陷来源于将人的眼睛视为一个点，实际上人眼是两个眼睛，而且会有不同的观察角度。对应这种复杂情况的显示，就是VR、裸眼3D等技术了。



# 第三章 碰撞检测

## 3.1 长方形物体间的碰撞检测

> 关键词：矩形、德摩根定律

**德摩根定律**：首先考虑两个物体什么情况下时不可能重叠的，比如有矩形1、矩形2两个矩形，如果矩形1的右端比矩形2的左端还靠左，那么就认为两个矩形不可能重叠（参考图3-1-3左）。同理，如果矩形1的左端比矩形2的右端还要靠右，也可以认为两个矩形不可能重叠（参考图3-1-3右）。

![](https://raw.githubusercontent.com/lightjiao/lightjiao.github.io/develop/static/images/038/3-1-3.png)

因此在与上述结论相反的情况下，两个矩形就可能重叠，即矩形1的右端比矩形2的左端靠右，并且矩形1的左端比矩形2的右端靠左时，两个矩形时可能重叠的。

❗❗❗ 当矩形的两端正好位于同一位置的情况，即“矩形1的右端与矩形2的左端正好在同一位置”：

矩形是基于左上角及右下角的坐标绘制的，而在现代硬件中，这样的矩形的右端及下端的最后1像素正好会被省略。

> 在现代的3D硬件中比如要绘制左上角为（10，10），右下角为（20，20）的矩形时，最左端的第10像素会被绘制，而最右端的第20像素一般则不会被绘制出来。垂直方向也一样，上端的第10像素会被绘制，而最下端的第20像素一般则不会被绘制。

至于为什么会有这样的设定，我也没有详细了解过，但按照这样的设定，并且考虑到让碰撞检测的可视化效果更加真实，当端与端位于同一位置时，我们认为设定其为没有碰撞。

不过这种处理方式不能作为开发类似程序的统一标准，因为在众多绘图硬件及程序库中，也许存在特例会将图形的右端及下端也进行绘制。因此端与端在同一位置的碰撞检测，还是需要根据具体情况来决定如何处理。



## 3.2 圆形与圆形、圆形与长方形物体间的碰撞检测

> 关键词：距离、勾股定理、平方比较

### 圆与圆之间的碰撞检测

判断两圆是否有碰撞，只要将两圆圆心之间的距离与两圆的半径之和比较即可（参考图3-2-2）。如此依赖就无需再考虑一个圆是否完全包含另一个圆，或者两圆之间是否有交点等情况。

![](https://raw.githubusercontent.com/lightjiao/lightjiao.github.io/develop/static/images/038/3-2-2.png)

计算公式也简单，使用勾股定理计算出圆心距离：
$$
l = \sqrt{(x_1 - x_2)^2 + (y_1 - y_2)^2}
$$
再和两圆的半径之和比较，如果小于则可判定为碰撞。

![](https://raw.githubusercontent.com/lightjiao/lightjiao.github.io/develop/static/images/038/3-2-3.png)

> ❗ 在计算机中计算时，可以不计算平凡根，性能开销比较大，可以直接比较两个数的平方
>
> 根据硬件结构的不同，两者的差距有时可达10倍以上。



### 圆形与长方形的碰撞检测

检测步骤：

1. 将需要检测的长方形，在上下左右4个方向均向外扩张，扩张的长度为圆半径r，如果扩张后得到新的长方形内包含了圆心坐标，则认为两物体具备碰撞的可能（反之则无碰撞的可能）。
2. 在满足条件1的情况下，如果圆心坐标在原长方形以外、扩展后的长方形的左上、左下、右上、右下四个角处，且圆内没有包含长方形最近的**顶点**，则认为两物体没有碰撞。

![](https://raw.githubusercontent.com/lightjiao/lightjiao.github.io/develop/static/images/038/3-2-4.png)

步骤1、2的判定参考图3-2-4。之所以通过这种方式检测，是因为要考虑圆形完全包含长方形，或者长方形完全包含圆形等情况。

具体来说，条件1的检测是以长方形为中心来考虑的。当圆心在原长方形之外，且与长方形的距离为r时，圆与长方形也有可能发生碰撞。但是扩张后长方形的四个角，即边长为r的正方形区域则需要特殊判断（参考图3-2-4）。

因为在这个区域中包含圆心的情况下，仍然存在圆的上下左右端都与原长方形不相交的可能性，这时就需要根据条件2进行判断。条件2的检测是以圆形为中心的，从这个角度出发来考虑圆形不包含长方形的情况应该更加容易理解。判断圆形不包含长方形，或者以圆形为中心检测时判断二者没有发生碰撞的最简单条件是：长方形的4个顶点中，离圆心最近的顶点没有在圆内。即当满足条件1而不满足条件2时，就可以认为两物体没有碰撞。



## 3.3 细长形物体与圆形物体间的碰撞检测

> 关键词：点与线段的距离、内积、微分

❗ “2D胶囊体”的数据结构

```
struct F_RECT_CIRCLE {
	float x, y;   // 2D胶囊体起点位置
	float vs, vy; // 2D胶囊体向量
	float r;      // 2D胶囊体碰撞大小
}
```

`F_RECT_CIRCLE`结构体通过一个点以及一个向量来表示一个线段，同时该结构体还包含此线段的有效距离，最终就可以表示一个倾斜长方形两端附加半圆形的细长图形（参考图3-3-2）。
![](https://raw.githubusercontent.com/lightjiao/lightjiao.github.io/develop/static/images/038/3-3-2.png)

思路：

计算圆心坐标到胶囊体中的线段的最短距离，然后再计算 “圆半径+胶囊体中线段的有效距离”，如果最短距离小于后者，则可认为两者碰撞。

结合公式与参考图3-3-3会更好理解一些：

![](https://raw.githubusercontent.com/lightjiao/lightjiao.github.io/develop/static/images/038/3-3-3.png)
$$
l_{min} < r_1 + r_2
$$
所以问题最终转换成了，要如何计算最短距离 l_min。

如果是直接计算点到直线的距离，那么可以用那个很有名的公式：

>$$
>直线 \space ax + by + c = 0 \space 与点 \space (x_0, y_0) \space 的最短距离为:
>$$
>$$
>\dfrac{|ax_0 + by_0 + c|}{\sqrt {a^2 + b^2}}
>$$

但很遗憾，我们的线段并不是一条无限延长的直线。

在程序中，为了适应更多的场景，直线往往都使用向量的形式来表示，即用向量 **a**、**b**将直线上的位置向量**p**表示为：
$$
\textbf{p} = \textbf{a}t + \textbf{b}
$$

限制t的大小来限制线段的长度，一般限制 0⩽t⩽1，即最终表示的是以位置向量 **b** 与位置向量 **b + a**为两端的线段。此时的计算方法如下：

1. 将线段上的点 p = at + b(0⩽t⩽1)与点(x0, y0)的距离表示为t的函数，然后对t进行微分，求得距离最小时的t。
2. 过点(x0, y0)向包含线段的直线 p = at + b 做一条垂线，使用向量的内积求得距离的最小值t。

方法1，就是通过求微分的方法找出极小值：
$$
令线段上的店p为(p_x, p_y)，向量a为(a_x, a_y)，向量b为(b_x, b_y)
$$
$$
p = at + b (0 \leqslant t \leqslant 1) 可以表示为
$$
$$
p_x = a_xt + b_x \space\space p_y = a_yt + b_y
$$

根据勾股定理有：
$$
l^2 = (p_x - x_0)^2 + (p_y - y_0)^2
$$

$$
l^2 = ({a_x}^2 + {a_y}^2)t^2 + 2\{ a_x(b_x - x_0) + a_y(b_y -y_0)\}t + {x_0}^2 + {y_0}^2
$$

对这个公式求最小值。对t进行微分，求一阶微分为0的t的值为l的极大值或极小值，而对t进行二阶微分发现二阶微分恒大于0，因此一阶微分为0时，l取极小值，公式如下：
$$
\dfrac{d(l^2)}{dt} = 2({a_x}^2 + {a_y}^2)t + 2\{ a_x(b_x - x_0) + a_y(b_y -y_0)\} = 0
$$
可得：
$$
t = \dfrac{a_x(x_0 - b_x) + a_y(y_0 - b_y)}{({a_x}^2 + {a_y}^2)}
$$
不过这样计算出来的结果，t可能会小于0，或者大于1，所以需要对t的范围做个限制

```
if (t < 0.0f) t = 0.0f;
if (t > 1.0f) t = 1.0f;
```

再用t取获取点的位置，求得两点之间的位置就很简单了。


#### ❗ 为什么游戏开发中要使用胶囊体，而不是倾斜的长方形呢？

> 首先倾斜的长方形与圆形的碰撞检测会有非常多的条件分支，导致程序很长。对于惯用指令流水线和推测执行的现代CPU来水，过多的分支条件不利于速度的优化。
>
> 其次，使用斜长方形作为碰撞检测的区域时，最终呈现的效果可能会有一些不合理的地方（即便从数学角度来看是正确的）。特别是当一个图形擦过长方形的四个角时，这种情况会被认为发生了碰撞，而肉眼看上去却是没有碰撞的，这样就在无形中给玩家带来了困扰。
>
> 因此为了让细长物体的两端更好的符合现实世界的碰撞现象，特意将四角处理为了圆形。



## 3.4 扇形物体的碰撞检测

> 条件划分、向量的运算、向量的内分点、圆的方程式

❗扇形的数据结构：

```
struct F_FAN 
{
	float x, y;             // 中心位置
	float vx1, vy1;         // 向量1
	float vx2, vy2;         // 向量2
	float fAngle1, fAngle2; // 各向量的角度(与碰撞检测无关)
	float r;                // 半径
}
```

与碰撞检测有关的部分，是一个点和两个向量，可以表示一个特定的扇形，其他的成员（角）可以暂时忽略。

![](https://raw.githubusercontent.com/lightjiao/lightjiao.github.io/develop/static/images/038/3-4-2.png)

思路：

1  扇形的圆心点，如果在圆形内部则表示碰撞（参考图3-4-3左）。  
~~2  圆的圆心坐标，如果在扇形内部则表示碰撞（参考图3-4-3右）。~~  
2'  圆形的圆心坐标在组成扇形的两个向量之间，并且圆形的圆心坐标到扇形的圆心坐标的距离，小于“圆形半径 + 扇形半径”时，认为两图形碰撞（参考图3-4-4左）。  
3  扇形的两个向量所构成的外侧边缘线段中，只要其中任意一条与圆有交点就认为碰撞（参考图3-4-4右）。  

条件1、2'、3（2'是2的超集），只要满足任意一个，都可以认为圆形与扇形有碰撞。

![](https://raw.githubusercontent.com/lightjiao/lightjiao.github.io/develop/static/images/038/3-4-3.png)

![](https://raw.githubusercontent.com/lightjiao/lightjiao.github.io/develop/static/images/038/3-4-4.png)

条件1的实现略

条件2'的实现：

> 圆形圆心的坐标表示为向量C，扇形的圆心表示为向量F，扇形的两个向量分别为v1和v2
>
> 只要满足公式 C - F = av1 + bv2，a > 0 & b > 0，那么就认为圆形的圆心坐标在扇形的两个向量之间
>
> 求出上述的a和b的过程为矩阵推导出的一个公式（运行时不会矩阵运算，只是推导过程用到了矩阵运算）
>
> ❗ 还有一种方法为通过向量的外积判断点是否在两向量之间，但是一般来说通过方程组求解的检测方式可以适用于更多的情况，因此这里采用了方程组求解的方式。

条件3的实现：

> 判断圆与**线段**的交点，注意是**线段**而不是**直线**。

实际项目中，大多数情况都会优先检测两物体绝对不可能碰撞的条件，即对圆的圆心与坐标与扇形圆形的坐标的距离是否大于“圆的半径 + 扇形的半径”进行检测，并将不可能碰撞的情况排除。比如挥剑时就可以使用这种检测方式，因为物体绝大多数情况下都是在剑的所及范围之外的。



## 3.5 [进阶]3D的碰撞检测

本书中并没有设计3D的碰撞检测，如果读者立志要成为游戏开发者，并且希望有较高身价的话，不妨以本书的2D碰撞检测为基础，去挑战更难得3D碰撞检测吧。

> 长方体和球之间得检测做了简单得距离，复杂有圆柱体、圆锥体，甚至每个物体做不同的旋转，做碰撞检测也很复杂。



# 第四章 光线的制作

## 4.1 让物体向任意方向旋转（含缩放效果）

> 关键词：旋转、基向量、向量加法、向量减法

### ❗为什么不使用旋转矩阵？

> - 目前我们是想通过倾斜一张光线素材图片来实现光线的投射，此时旋转矩阵就不太适用了。因为游戏中在投射光线等物体时，其投射方向的角度往往是未知的，一般只能知道光线的起点及终点
> - 在起点和终点确定的情况下如果采用旋转矩阵来倾斜物体，首先就需要链接起点与终点得到一条直线，然后求得这条直线与x轴的夹角，通过夹角就可以得到一个旋转矩阵并控制物体的旋转。
> - 但这种计算方法很浪费性能。求角度、并通过角度确定旋转矩阵来控制旋转，本质上是将普通的坐标系转换到包含角度的特殊坐标系，然后再重新转回普通坐标系，如果只是让物体旋转，这些坐标系的转换其实都是多余的。
> - 从工程学的角度来看，求直线与x轴的夹角会用到反三角函数（如C语言中的`atan2`等）反三角函数的计算更花时间，应该尽量避免使用。

### ❗我们使用**基变换**来实现旋转物体

> 基变换就是对基向量进行的变换。

普通坐标系下基向量 `i = (1, 0)` `y = (0, 1)`，将这两个基向量组合可以表示普通坐标系下任意的向量表示为如下形式：
$$
x\bold{i} + y\bold{j}
$$
这样一来，即使不更改 x、y，而只是将 i、j 旋转指向特定的方向，也可以实现物体的旋转（参考图4-1-2）
![](https://raw.githubusercontent.com/lightjiao/lightjiao.github.io/develop/static/images/038/4-1-2.png)

假设这样得到的一对新的基向量为 i'、j' ，然后进行心坐标系的坐标变换，坐标为 (x, y) 的点 P，即 P = xi + yj 这个点，就移动到了点 P' = xi' + yj'。可将其用分量表示为：

![](https://raw.githubusercontent.com/lightjiao/lightjiao.github.io/develop/static/images/038/4-1-2.2.png)

也就是说，只要将新的基向量 i'、 j' 的分量表示为矩阵形式，就可以得到从一般坐标系到心坐标系的变换矩阵。这是一个非常方便的数学结论，最好可以背下来。

> ❗  三维、四维矩阵应该也是有类似的特例技巧的
>
> 这个矩阵可以快速的求得向量的旋转后的位置，比起使用三角函数或者反三角函数更加的高效。



## 4.2 任意两点间的光纤投射

> 关键词：向量长度、单位向量

略



## 4.3 光线弯曲处理

> 关键词：圆形、圆周长、伪影

❗ 计算机一般都不支持直接绘制曲线，只能自由绘制三角多边形，因此将光纤的圆环按角度方向分割为若干个很小的三角多边形，就可以通过三角多边形最终绘制出圆环（参考图4-3-2）。
![](https://raw.githubusercontent.com/lightjiao/lightjiao.github.io/develop/static/images/038/4-3-2.png)
决定分割数的方法有很多，这里按照分割后圆周长的一份约为10像素来决定分割数。
但如果这个分割数过大，所需要的顶点数也会增多，这时就可能有缓冲区移除的风险，因此这里对分割数设置了`MAX_DIVIDE_NUM`这一上限。



## 4.4 实现带追踪效果的激光
> 关键词：左右判定、外积、旋转速度

![](https://raw.githubusercontent.com/lightjiao/lightjiao.github.io/develop/static/images/038/4-4-3.png)

- ### 判断一个向量是在左侧还是右侧

> - 使用反三角函数计算夹角，再判断夹角的大于零小于零，性能不是最优
>
>   使用Unity 的API `Vector3.SignedAngle()` 可以实现这个效果
>
> - 使用**向量的外积**（a ✖ b ），叉乘的结果是个向量，向量的方向取决于叉乘的顺序，可以根据叉乘结果的方向来判断原始向量的位置关系。

- ### 书中的例子解析：

  - 将激光分为均匀的小段，一段30个像素，每一个小段都是两个三角形组成的，具体可看上一小节【光线弯曲处理】

  - 每一段激光根据所在线段的下标，取一个旋转的角度。根据这个旋转角度算出线段的位置

  - 根据当前方向与目标方向的夹角取sin值，加成到速度变化中，使得旋转速度的变化在越接近目标时候越平缓（旋转朝向越接近目标方向，sin值越小，下一个线段的旋转速度变化就越小）



## 4.5 [进阶] 绘制大幅度弯曲的曲线时的难点

> 关键词：曲率、曲线的粗细、插值曲线、反射
